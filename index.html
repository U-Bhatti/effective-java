<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Effective Java</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <link href="reset.css" rel="stylesheet">
    <link href="code-highlights.css" rel="stylesheet">
    <link href="styles.css" rel="stylesheet">
</head>
<body>
    <div id="editable">
        <!-- item 44 -->
        <div>
            <h1 style="cursor: default;" title="">Item 44: Favor the use of standard functional interfaces</h1>

            <p style="cursor: default;" title="">Now that Java has lambdas, best practices for writing APIs have changed
                considerably. For example, the
                Template Method pattern <span>[Gamma95]</span>, wherein a subclass overrides a primitive method to
                specialize the behavior of its superclass, is far less attractive. The modern alternative is to provide
                a
                static factory or constructor that accepts a function object to achieve the same effect. More generally,
                you’ll be writing more constructors and methods that take function objects as parameters. Choosing the
                right
                functional parameter type demands care.</p>

            <p style="cursor: default;" title="">Consider <code>LinkedHashMap</code>. You can use this class as a cache
                by
                overriding its protected
                <code>removeEldestEntry</code> method, which is invoked by <code>put</code> each time a new key is added
                to
                the map. When this method returns true, the map removes its eldest entry, which is passed to the method.
                The
                following override allows the map to grow to one hundred entries and then deletes the eldest entry each
                time
                a new key is added, maintaining the hundred most recent entries:
            </p>
            <pre><code class="language-java hljs">    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeEldestEntry</span><span class="hljs-params">(Map.Entry&lt;K,V&gt; eldest)</span> {
        <span class="hljs-keyword">return</span> size() &gt; <span class="hljs-number">100</span>;
    }</code></pre>

            <p>This technique works fine, but you can do much better with lambdas. If <code>LinkedHashMap</code> were
                written today, it would have a static factory or constructor that took a function object. Looking at the
                declaration for <code>removeEldestEntry</code>, you might think that the function object should take a
                <code>Map.Entry&lt;K,V&gt;</code> and return a boolean, but that wouldn’t quite do it: The
                <code>removeEldestEntry</code> method calls <code>size()</code> to get the number of entries in the map,
                which works because <code>removeEldestEntry</code> is an instance method on the map. The function object
                that you pass to the constructor is not an instance method on the map and can’t capture it because the
                map
                doesn’t exist yet when its factory or constructor is invoked. Thus, the map must pass itself to the
                function
                object, which must therefore take the map on input as well as its eldest entry. If you were to declare
                such
                a functional interface, it would look something like this:
            </p>
            <pre><code class="language-java hljs">    <span class="hljs-comment">// Unnecessary functional interface; use a standard one instead.</span>
    <span class="hljs-meta">@FunctionalInterface</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EldestEntryRemovalFunction</span>&lt;K,V&gt;{
        <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Map&lt;K,V&gt; map, Map.Entry&lt;K,V&gt; eldest)</span>;
    }     </code></pre>

            <p>This interface would work fine, but you shouldn’t use it, because you don’t need to declare a new
                interface
                for this purpose. The <code>java.util.function</code> package provides a large collection of standard
                functional interfaces for your use.</p>

            <p>If one of the standard functional interfaces does the job, you should generally use it in preference to a
                purpose-built functional interface. This will make your API easier to learn, by reducing its conceptual
                surface area, and will provide significant interoperability benefits, as many of the standard functional
                interfaces provide useful default methods. The <code>Predicate</code> interface, for instance, provides
                methods to combine predicates. In the case of our <code>LinkedHashMap</code> example, the standard
                <code>BiPredicate&lt;Map&lt;K,V&gt;, Map.Entry&lt;K,V&gt;&gt;</code> interface should be used in
                preference
                to a custom <code>EldestEntryRemovalFunction</code> interface.
            </p>

            <p>There are forty-three interfaces in <code>java.util.function</code>. You can’t be expected to remember
                them
                all, but if you remember six basic interfaces, you can derive the rest when you need them. The basic
                interfaces operate on object reference types. The <code>Operator</code> interfaces represent functions
                whose
                result and argument types are the same. The <code>Predicate</code> interface represents a function that
                takes an argument and returns a boolean. The <code>Function</code> interface represents a function whose
                argument and return types differ. The <code>Supplier</code> interface represents a function that takes
                no
                arguments and returns (or “supplies”) a value. Finally, <code>Consumer</code> represents a function that
                takes an argument and returns nothing, essentially consuming its argument. The six basic functional
                interfaces are summarized below:</p>

            <p>There are also three variants of each of the six basic interfaces to operate on the primitive types
                <code>int</code>, <code>long</code>, and <code>double</code>. Their names are derived from the basic
                interfaces by prefixing them with a primitive type. So, for example, a predicate that takes an
                <code>int</code> is an <code>IntPredicate</code>, and a binary operator that takes two <code>long</code>
                values and returns a <code>long</code> is a <code>LongBinaryOperator</code>. None of these variant types
                is
                parameterized except for the <code>Function</code> variants, which are parameterized by return type. For
                example, <code>LongFunction&lt;int[]&gt;</code> takes a <code>long</code> and returns an
                <code>int[]</code>.
            </p>

            <table>
                <thead>
                    <tr>
                        <th>Interface</th>
                        <th>Function Signature</th>
                        <th>Example</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>UnaryOperator&lt;T&gt;</td>
                        <td>T apply(T t)</td>
                        <td><code>String::toLowerCase</code></td>
                    </tr>
                    <tr>
                        <td>BinaryOperator&lt;T&gt;</td>
                        <td>T apply(T t1, T t2)</td>
                        <td><code>BigInteger::add</code></td>
                    </tr>
                    <tr>
                        <td>Predicate&lt;T&gt;</td>
                        <td>boolean test(T t)</td>
                        <td><code>Collection::isEmpty</code></td>
                    </tr>
                    <tr>
                        <td>Function&lt;T,R&gt;</td>
                        <td>R apply(T t)</td>
                        <td><code>Arrays::asList</code></td>
                    </tr>
                    <tr>
                        <td>Supplier&lt;T&gt;</td>
                        <td>T get()</td>
                        <td><code>Instant::now</code></td>
                    </tr>
                    <tr>
                        <td>Consumer&lt;T&gt;</td>
                        <td>void accept(T t)</td>
                        <td><code>System.out::println</code></td>
                    </tr>
                </tbody>
            </table>

            <p>There are nine additional variants of the <code>Function</code> interface, for use when the result type
                is
                primitive. The source and result types always differ, because a function from a type to itself is a
                <code>UnaryOperator</code>. If both the source and result types are primitive, prefix
                <code>Function</code>
                with <code>SrcToResult</code>, for example <code>LongToIntFunction</code> (six variants). If the source
                is a
                primitive and the result is an object reference, prefix <code>Function</code> with
                <code>&lt;Src&gt;ToObj</code>, for example <code>DoubleToObjFunction</code> (three variants).
            </p>

            <p>There are two-argument versions of the three basic functional interfaces for which it makes sense to have
                them: <code>BiPredicate&lt;T,U&gt;</code>, <code>BiFunction&lt;T,U,R&gt;</code>, and
                <code>BiConsumer&lt;T,U&gt;</code>. There are also <code>BiFunction</code> variants returning the three
                relevant primitive types: <code>ToIntBiFunction&lt;T,U&gt;</code>,
                <code>ToLongBiFunction&lt;T,U&gt;</code>,
                and <code>ToDoubleBiFunction&lt;T,U&gt;</code>. There are two-argument variants of <code>Consumer</code>
                that take one object reference and one primitive type: <code>ObjDoubleConsumer&lt;T&gt;</code>,
                <code>ObjIntConsumer&lt;T&gt;</code>, and <code>ObjLongConsumer&lt;T&gt;</code>. In total, there are
                nine
                two-argument versions of the basic interfaces.
            </p>

            <p>Finally, there is the <code>BooleanSupplier</code> interface, a variant of <code>Supplier</code> that
                returns
                boolean values. This is the only explicit mention of the boolean type in any of the standard functional
                interface names, but boolean return values are supported via <code>Predicate</code> and its four variant
                forms. The <code>BooleanSupplier</code> interface and the forty-two interfaces described in the previous
                paragraphs account for all forty-three standard functional interfaces. Admittedly, this is a lot to
                swallow,
                and not terribly orthogonal. On the other hand, the bulk of the functional interfaces that you’ll need
                have
                been written for you and their names are regular enough that you shouldn’t have too much trouble coming
                up
                with one when you need it.</p>

            <p>Most of the standard functional interfaces exist only to provide support for primitive types. Don’t be
                tempted to use basic functional interfaces with boxed primitives instead of primitive functional
                interfaces.
                While it works, it violates the advice of Item 61, “prefer primitive types to boxed primitives.” The
                performance consequences of using boxed primitives for bulk operations can be deadly.</p>

            <p>Now you know that you should typically use standard functional interfaces in preference to writing your
                own.
                But when should you write your own? Of course you need to write your own if none of the standard ones
                does
                what you need, for example if you require a predicate that takes three parameters, or one that throws a
                checked exception. But there are times you should write your own functional interface even when one of
                the
                standard ones is structurally identical.</p>

            <p>Consider our old friend <code>Comparator&lt;T&gt;</code>, which is structurally identical to the
                <code>ToIntBiFunction&lt;T,T&gt;</code> interface. Even if the latter interface had existed when the
                former
                was added to the libraries, it would have been wrong to use it. There are several reasons that
                <code>Comparator</code> deserves its own interface. First, its name provides excellent documentation
                every
                time it is used in an API, and it’s used a lot. Second, the <code>Comparator</code> interface has strong
                requirements on what constitutes a valid instance, which comprise its general contract. By implementing
                the
                interface, you are pledging to adhere to its contract. Third, the interface is heavily outfitted with
                useful
                default methods to transform and combine comparators.
            </p>

            <p>You should seriously consider writing a purpose-built functional interface in preference to using a
                standard
                one if you need a functional interface that shares one or more of the following characteristics with
                <code>Comparator</code>:
            </p>
            <ul>
                <li>It will be commonly used and could benefit from a descriptive name.</li>
                <li>It has a strong contract associated with it.</li>
                <li>It would benefit from custom default methods.</li>
            </ul>

            <p>If you elect to write your own functional interface, remember that it’s an interface and hence should be
                designed with great care (Item 21).</p>

            <p>Notice that the <code>EldestEntryRemovalFunction</code> interface (page 199) is labeled with the
                <code>@FunctionalInterface</code> annotation. This annotation type is similar in spirit to
                <code>@Override</code>. It is a statement of programmer intent that serves three purposes: it tells
                readers
                of the class and its documentation that the interface was designed to enable lambdas; it keeps you
                honest
                because the interface won’t compile unless it has exactly one abstract method; and it prevents
                maintainers
                from accidentally adding abstract methods to the interface as it evolves. Always annotate your
                functional
                interfaces with the <code>@FunctionalInterface</code> annotation.
            </p>

            <p>A final point should be made concerning the use of functional interfaces in APIs. Do not provide a method
                with multiple overloadings that take different functional interfaces in the same argument position if it
                could create a possible ambiguity in the client. This is not just a theoretical problem. The
                <code>submit</code> method of <code>ExecutorService</code> can take either a
                <code>Callable&lt;T&gt;</code>
                or a <code>Runnable</code>, and it is possible to write a client program that requires a cast to
                indicate
                the correct overloading (Item 52). The easiest way to avoid this problem is not to write overloadings
                that
                take different functional interfaces in the same argument position. This is a special case of the advice
                in
                Item 52, “use overloading judiciously.”
            </p>

            <p>In summary, now that Java has lambdas, it is imperative that you design your APIs with lambdas in mind.
                Accept functional interface types on input and return them on output. It is generally best to use the
                standard interfaces provided in <code>java.util.function</code>, but keep your eyes open for the
                relatively
                rare cases where you would be better off writing your own functional interface.</p>
        </div>
        <!-- item 45 -->
        <div>
            <h1>Item 45: Use streams judiciously</h1>

            <p>The streams API was added in Java 8 to ease the task of performing bulk operations, sequentially or in
                parallel. This API provides two key abstractions: the stream, which represents a finite or infinite
                sequence
                of data elements, and the stream pipeline, which represents a multistage computation on these elements.
                The
                elements in a stream can come from anywhere. Common sources include collections, arrays, files, regular
                expression pattern matchers, pseudorandom number generators, and other streams. The data elements in a
                stream can be object references or primitive values. Three primitive types are supported:
                <code>int</code>,
                <code>long</code>, and <code>double</code>.
            </p>
            <div class="rte">.</div>
            <p>A stream pipeline consists of a source stream followed by zero or more intermediate operations and one
                terminal operation. Each intermediate operation transforms the stream in some way, such as mapping each
                element to a function of that element or filtering out all elements that do not satisfy some condition.
                Intermediate operations all transform one stream into another, whose element type may be the same as the
                input stream or different from it. The terminal operation performs a final computation on the stream
                resulting from the last intermediate operation, such as storing its elements into a collection,
                returning a
                certain element, or printing all of its elements.</p>

            <p>Stream pipelines are evaluated lazily: evaluation doesn’t start until the terminal operation is invoked,
                and
                data elements that aren’t required in order to complete the terminal operation are never computed. This
                lazy
                evaluation is what makes it possible to work with infinite streams. Note that a stream pipeline without
                a
                terminal operation is a silent no-op, so don’t forget to include one.</p>

            <p>The streams API is fluent: it is designed to allow all of the calls that comprise a pipeline to be
                chained
                into a single expression. In fact, multiple pipelines can be chained together into a single expression.
            </p>

            <p>By default, stream pipelines run sequentially. Making a pipeline execute in parallel is as simple as
                invoking
                the <code>parallel</code> method on any stream in the pipeline, but it is seldom appropriate to do so
                (Item
                48).</p>

            <p>The streams API is sufficiently versatile that practically any computation can be performed using
                streams,
                but just because you can doesn’t mean you should. When used appropriately, streams can make programs
                shorter
                and clearer; when used inappropriately, they can make programs difficult to read and maintain. There are
                no
                hard and fast rules for when to use streams, but there are heuristics.</p>

            <p>Consider the following program, which reads the words from a dictionary file and prints all the anagram
                groups whose size meets a user-specified minimum. Recall that two words are anagrams if they consist of
                the
                same letters in a different order. The program reads each word from a user-specified dictionary file and
                places the words into a map. The map key is the word with its letters alphabetized, so the key for
                "staple"
                is "aelpst", and the key for "petals" is also "aelpst": the two words are anagrams, and all anagrams
                share
                the same alphabetized form (or alphagram, as it is sometimes known). The map value is a list containing
                all
                of the words that share an alphabetized form. After the dictionary has been processed, each list is a
                complete anagram group. The program then iterates through the map’s <code>values()</code> view and
                prints
                each list whose size meets the threshold:</p>
            <pre><code class="language-java hljs">    <span class="hljs-comment">// Prints all large anagram groups in a dictionary iteratively</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Anagrams</span> {
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException {
            <span class="hljs-type">File</span> <span class="hljs-variable">dictionary</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(args[<span class="hljs-number">0</span>]);
            <span class="hljs-type">int</span> <span class="hljs-variable">minGroupSize</span> <span class="hljs-operator">=</span> Integer.parseInt(args[<span class="hljs-number">1</span>]);
            Map&lt;String, Set&lt;String&gt;&gt; groups = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();</code><code class="language-java hljs">            <span class="hljs-keyword">try</span> (<span class="hljs-type">Scanner</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(dictionary)) {
                <span class="hljs-keyword">while</span> (s.hasNext()) {
                    <span class="hljs-type">String</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> s.next();
                    groups.computeIfAbsent(alphabetize(word), (unused) -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;()).add(word);
                }
            }</code><code class="language-java hljs">            <span class="hljs-keyword">for</span> (Set&lt;String&gt; group : groups.values())
                <span class="hljs-keyword">if</span> (group.size() &gt;= minGroupSize)
                    System.out.println(group.size() + <span class="hljs-string">": "</span> + group);
        }</code><code class="language-java hljs">        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">alphabetize</span><span class="hljs-params">(String s)</span> {
            <span class="hljs-type">char</span>[] a = s.toCharArray();
            Arrays.sort(a);
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(a);
        }
    }    </code></pre>

            <p>One step in this program is worthy of note. The insertion of each word into the map, which is shown in
                bold,
                uses the <code>computeIfAbsent</code> method, which was added in Java 8. This method looks up a key in
                the
                map: If the key is present, the method simply returns the value associated with it. If not, the method
                computes a value by applying the given function object to the key, associates this value with the key,
                and
                returns the computed value. The <code>computeIfAbsent</code> method simplifies the implementation of
                maps
                that associate multiple values with each key.</p>

            <p>Now consider the following program, which solves the same problem, but makes heavy use of streams. Note
                that
                the entire program, with the exception of the code that opens the dictionary file, is contained in a
                single
                expression. The only reason the dictionary is opened in a separate expression is to allow the use of the
                try-with-resources statement, which ensures that the dictionary file is closed:</p>
            <pre><code class="language-java hljs">    <span class="hljs-comment">// Overuse of streams - don't do this!</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Anagrams</span> {
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException {
            <span class="hljs-type">Path</span> <span class="hljs-variable">dictionary</span> <span class="hljs-operator">=</span> Paths.get(args[<span class="hljs-number">0</span>]);
            <span class="hljs-type">int</span> <span class="hljs-variable">minGroupSize</span> <span class="hljs-operator">=</span> Integer.parseInt(args[<span class="hljs-number">1</span>]);
            <span class="hljs-keyword">try</span> (Stream&lt;String&gt; words = Files.lines(dictionary)) {
                words.collect(
                    groupingBy(word -&gt; word.chars().sorted()
                        .collect(StringBuilder::<span class="hljs-keyword">new</span>, (sb, c) -&gt; sb.append((<span class="hljs-type">char</span>) c), StringBuilder::append).toString()))
                    .values().stream()
                    .filter(group -&gt; group.size() &gt;= minGroupSize)
                    .map(group -&gt; group.size() + <span class="hljs-string">": "</span> + group)
                    .forEach(System.out::println);
            }
        }
    }</code></pre>

            <p>If you find this code hard to read, don’t worry; you’re not alone. It is shorter, but it is also less
                readable, especially to programmers who are not experts in the use of streams. Overusing streams makes
                programs hard to read and maintain.</p>

            <p>Luckily, there is a happy medium. The following program solves the same problem, using streams without
                overusing them. The result is a program that’s both shorter and clearer than the original:</p>
            <pre><code class="language-java hljs">    <span class="hljs-comment">// Tasteful use of streams enhances clarity and conciseness</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Anagrams</span> {
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException {
            <span class="hljs-type">Path</span> <span class="hljs-variable">dictionary</span> <span class="hljs-operator">=</span> Paths.get(args[<span class="hljs-number">0</span>]);
            <span class="hljs-type">int</span> <span class="hljs-variable">minGroupSize</span> <span class="hljs-operator">=</span> Integer.parseInt(args[<span class="hljs-number">1</span>]);
            <span class="hljs-keyword">try</span> (Stream&lt;String&gt; words = Files.lines(dictionary)) {
                words.collect(groupingBy(word -&gt; alphabetize(word)))
                    .values().stream()
                    .filter(group -&gt; group.size() &gt;= minGroupSize)
                    .forEach(g -&gt; System.out.println(g.size() + <span class="hljs-string">": "</span> + g));
            }
        }
        <span class="hljs-comment">// alphabetize method is the same as in original version</span>
    }    </code></pre>

            <p>Even if you have little previous exposure to streams, this program is not hard to understand. It opens
                the
                dictionary file in a try-with-resources block, obtaining a stream consisting of all the lines in the
                file.
                The stream variable is named <code>words</code> to suggest that each element in the stream is a word.
                The
                pipeline on this stream has no intermediate operations; its terminal operation collects all the words
                into a
                map that groups the words by their alphabetized form (Item 46). This is exactly the same map that was
                constructed in both previous versions of the program. Then a new
                <code>Stream&lt;List&lt;String&gt;&gt;</code> is opened on the <code>values()</code> view of the map.
                The
                elements in this stream are, of course, the anagram groups. The stream is filtered so that all of the
                groups
                whose size is less than <code>minGroupSize</code> are ignored, and finally, the remaining groups are
                printed
                by the terminal operation <code>forEach</code>.
            </p>

            <p>Note that the lambda parameter names were chosen carefully. The parameter <code>g</code> should really be
                named <code>group</code>, but the resulting line of code would be too wide for the book. In the absence
                of
                explicit types, careful naming of lambda parameters is essential to the readability of stream pipelines.
            </p>

            <p>Note also that word alphabetization is done in a separate <code>alphabetize</code> method. This enhances
                readability by providing a name for the operation and keeping implementation details out of the main
                program. Using helper methods is even more important for readability in stream pipelines than in
                iterative
                code because pipelines lack explicit type information and named temporary variables. The
                <code>alphabetize</code> method could have been reimplemented to use streams, but a stream-based
                <code>alphabetize</code> method would have been less clear, more difficult to write correctly, and
                probably
                slower. These deficiencies result from Java’s lack of support for primitive <code>char</code> streams
                (which
                is not to imply that Java should have supported <code>char</code> streams; it would have been infeasible
                to
                do so). To demonstrate the hazards of processing <code>char</code> values with streams, consider the
                following code:
            </p>

            <pre><code class="language-java hljs"><span class="hljs-string">"Hello world!"</span>.chars().forEach(System.out::print);</code></pre>

            <p>You might expect it to print <code>Hello world!</code>, but if you run it, you’ll find that it prints
                <code>721011081081113211911111410810033</code>. This happens because the elements of the stream returned
                by
                <code>"Hello world!".chars()</code> are not <code>char</code> values but <code>int</code> values, so the
                <code>int</code> overloading of <code>print</code> is invoked. It is admittedly confusing that a method
                named <code>chars</code> returns a stream of <code>int</code> values. You could fix the program by using
                a
                cast to force the invocation of the correct overloading:
            </p>

            <pre><code class="language-java hljs"><span class="hljs-string">"Hello world!"</span>.chars().forEach(x -&gt; System.out.print((<span class="hljs-type">char</span>) x));</code></pre>

            <p>but ideally you should refrain from using streams to process <code>char</code> values.</p>

            <p>When you start using streams, you may feel the urge to convert all your loops into streams, but resist
                the
                urge. While it may be possible, it will likely harm the readability and maintainability of your code
                base.
                As a rule, even moderately complex tasks are best accomplished using some combination of streams and
                iteration, as illustrated by the Anagrams programs above. So refactor existing code to use streams and
                use
                them in new code only where it makes sense to do so.</p>

            <p>As shown in the programs in this item, stream pipelines express repeated computation using function
                objects
                (typically lambdas or method references), while iterative code expresses repeated computation using code
                blocks. There are some things you can do from code blocks that you can’t do from function objects:</p>
            <ul>
                <li>From a code block, you can read or modify any local variable in scope; from a lambda, you can only
                    read
                    final or effectively final variables [JLS 4.12.4], and you can’t modify any local variables.</li>
                <li>From a code block, you can return from the enclosing method, break or continue an enclosing loop, or
                    throw any checked exception that this method is declared to throw; from a lambda you can do none of
                    these things.</li>
            </ul>

            <p>If a computation is best expressed using these techniques, then it’s probably not a good match for
                streams.
                Conversely, streams make it very easy to do some things:</p>
            <ul>
                <li>Uniformly transform sequences of elements</li>
                <li>Filter sequences of elements</li>
                <li>Combine sequences of elements using a single operation (for example to add them, concatenate them,
                    or
                    compute their minimum)</li>
                <li>Accumulate sequences of elements into a collection, perhaps grouping them by some common attribute
                </li>
                <li>Search a sequence of elements for an element satisfying some criterion</li>
            </ul>

            <p>If a computation is best expressed using these techniques, then it is a good candidate for streams.</p>

            <p>One thing that is hard to do with streams is to access corresponding elements from multiple stages of a
                pipeline simultaneously: once you map a value to some other value, the original value is lost. One
                workaround is to map each value to a pair object containing the original value and the new value, but
                this
                is not a satisfying solution, especially if the pair objects are required for multiple stages of a
                pipeline.
                The resulting code is messy and verbose, which defeats a primary purpose of streams. When it is
                applicable,
                a better workaround is to invert the mapping when you need access to the earlier-stage value.</p>

            <p>For example, let’s write a program to print the first twenty Mersenne primes. To refresh your memory, a
                Mersenne number is a number of the form <code>2<sup>p</sup> − 1</code>. If <code>p</code> is prime, the
                corresponding Mersenne number may be prime; if so, it’s a Mersenne prime. As the initial stream in our
                pipeline, we want all the prime numbers. Here’s a method to return that (infinite) stream. We assume a
                static import has been used for easy access to the static members of <code>BigInteger</code>:</p>
            <pre><code class="language-java hljs">    <span class="hljs-keyword">static</span> Stream&lt;BigInteger&gt; <span class="hljs-title function_">primes</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> Stream.iterate(TWO, BigInteger::nextProbablePrime);
    }</code></pre>

            <p>The name of the method (<code>primes</code>) is a plural noun describing the elements of the stream. This
                naming convention is highly recommended for all methods that return streams because it enhances the
                readability of stream pipelines. The method uses the static factory <code>Stream.iterate</code>, which
                takes
                two parameters: the first element in the stream, and a function to generate the next element in the
                stream
                from the previous one. Here is the program to print the first twenty Mersenne primes:</p>
            <pre><code class="language-java hljs">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        primes().map(p -&gt; TWO.pow(p.intValueExact()).subtract(ONE))
            .filter(mersenne -&gt; mersenne.isProbablePrime(<span class="hljs-number">50</span>))
            .limit(<span class="hljs-number">20</span>)
            .forEach(System.out::println);
    }    </code></pre>

            <p>This program is a straightforward encoding of the prose description above: it starts with the primes,
                computes the corresponding Mersenne numbers, filters out all but the primes (the magic number 50
                controls
                the probabilistic primality test), limits the resulting stream to twenty elements, and prints them out.
            </p>

            <p>Now suppose that we want to precede each Mersenne prime with its exponent (<code>p</code>). This value is
                present only in the initial stream, so it is inaccessible in the terminal operation, which prints the
                results. Luckily, it’s easy to compute the exponent of a Mersenne number by inverting the mapping that
                took
                place in the first intermediate operation. The exponent is simply the number of bits in the binary
                representation, so this terminal operation generates the desired result:</p>

            <pre><code class="language-java hljs">.forEach(mp -&gt; System.out.println(mp.bitLength() + <span class="hljs-string">": "</span> + mp));</code></pre>

            <p>There are plenty of tasks where it is not obvious whether to use streams or iteration. For example,
                consider
                the task of initializing a new deck of cards. Assume that <code>Card</code> is an immutable value class
                that
                encapsulates a <code>Rank</code> and a <code>Suit</code>, both of which are enum types. This task is
                representative of any task that requires computing all the pairs of elements that can be chosen from two
                sets. Mathematicians call this the Cartesian product of the two sets. Here’s an iterative implementation
                with a nested for-each loop that should look very familiar to you:</p>
            <pre><code class="language-java hljs">    <span class="hljs-comment">// Iterative Cartesian product computation</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;Card&gt; <span class="hljs-title function_">newDeck</span><span class="hljs-params">()</span> {
        List&lt;Card&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        <span class="hljs-keyword">for</span> (Suit suit : Suit.values())
            <span class="hljs-keyword">for</span> (Rank rank : Rank.values())
                result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Card</span>(suit, rank));
        <span class="hljs-keyword">return</span> result;
    }</code></pre>

            <p>And here is a stream-based implementation that makes use of the intermediate operation
                <code>flatMap</code>.
                This operation maps each element in a stream to a stream and then concatenates all of these new streams
                into
                a single stream (or flattens them). Note that this implementation contains a nested lambda, shown in
                boldface:
            </p>
            <pre><code class="language-java hljs">    <span class="hljs-comment">// Stream-based Cartesian product computation</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;Card&gt; <span class="hljs-title function_">newDeck</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> Stream.of(Suit.values())
            .flatMap(suit -&gt;
                Stream.of(Rank.values())
                    .map(rank -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Card</span>(suit, rank)))
            .collect(toList());
    } </code></pre>

            <p>Which of the two versions of <code>newDeck</code> is better? It boils down to personal preference and the
                environment in which you’re programming. The first version is simpler and perhaps feels more natural. A
                larger fraction of Java programmers will be able to understand and maintain it, but some programmers
                will
                feel more comfortable with the second (stream-based) version. It’s a bit more concise and not too
                difficult
                to understand if you’re reasonably well-versed in streams and functional programming. If you’re not sure
                which version you prefer, the iterative version is probably the safer choice. If you prefer the stream
                version and you believe that other programmers who will work with the code will share your preference,
                then
                you should use it.</p>

            <p>In summary, some tasks are best accomplished with streams, and others with iteration. Many tasks are best
                accomplished by combining the two approaches. There are no hard and fast rules for choosing which
                approach
                to use for a task, but there are some useful heuristics. In many cases, it will be clear which approach
                to
                use; in some cases, it won’t. If you’re not sure whether a task is better served by streams or
                iteration,
                try both and see which works better.</p>
        </div>
        <!-- item 46 -->
        <div>
            <h1>Item 46: Prefer side-effect-free functions in streams</h1>

            <p>If you’re new to streams, it can be difficult to get the hang of them. Merely expressing your computation
                as
                a stream pipeline can be hard. When you succeed, your program will run, but you may realize little if
                any
                benefit. Streams isn’t just an API, it’s a paradigm based on functional programming. In order to obtain
                the
                expressiveness, speed, and in some cases parallelizability that streams have to offer, you have to adopt
                the
                paradigm as well as the API.</p>

            <p>The most important part of the streams paradigm is to structure your computation as a sequence of
                transformations where the result of each stage is as close as possible to a pure function of the result
                of
                the previous stage. A pure function is one whose result depends only on its input: it does not depend on
                any
                mutable state, nor does it update any state. In order to achieve this, any function objects that you
                pass
                into stream operations, both intermediate and terminal, should be free of side-effects.</p>

            <p>Occasionally, you may see streams code that looks like this snippet, which builds a frequency table of
                the
                words in a text file:</p>
            <pre><code class="language-java hljs">    <span class="hljs-comment">// Uses the streams API but not the paradigm--Don't do this!</span>
    <span class="hljs-type">Map</span> <span class="hljs-variable">freq</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
    <span class="hljs-keyword">try</span> (<span class="hljs-type">Stream</span> <span class="hljs-variable">words</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(file).tokens()) {
        words.forEach(word -&gt; {
            freq.merge(word.toLowerCase(), <span class="hljs-number">1L</span>, Long::sum);
        });
    } </code></pre>

            <p>What’s wrong with this code? After all, it uses streams, lambdas, and method references, and gets the
                right
                answer. Simply put, it’s not streams code at all; it’s iterative code masquerading as streams code. It
                derives no benefits from the streams API, and it’s (a bit) longer, harder to read, and less maintainable
                than the corresponding iterative code. The problem stems from the fact that this code is doing all its
                work
                in a terminal <code>forEach</code> operation, using a lambda that mutates external state (the frequency
                table). A <code>forEach</code> operation that does anything more than present the result of the
                computation
                performed by a stream is a “bad smell in code,” as is a lambda that mutates state. So how should this
                code
                look?</p>
            <pre><code class="language-java hljs">    <span class="hljs-comment">// Proper use of streams to initialize a frequency table</span>
    Map freq;
    <span class="hljs-keyword">try</span> (<span class="hljs-type">Stream</span> <span class="hljs-variable">words</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(file).tokens()) {
        freq = words
            .collect(groupingBy(String::toLowerCase, counting()));
    }</code></pre>

            <p>This snippet does the same thing as the previous one but makes proper use of the streams API. It’s
                shorter
                and clearer. So why would anyone write it the other way? Because it uses tools they’re already familiar
                with. Java programmers know how to use for-each loops, and the <code>forEach</code> terminal operation
                is
                similar. But the <code>forEach</code> operation is among the least powerful of the terminal operations
                and
                the least stream-friendly. It’s explicitly iterative, and hence not amenable to parallelization. The
                <code>forEach</code> operation should be used only to report the result of a stream computation, not to
                perform the computation. Occasionally, it makes sense to use <code>forEach</code> for some other
                purpose,
                such as adding the results of a stream computation to a preexisting collection.
            </p>

            <p>The improved code uses a collector, which is a new concept that you have to learn in order to use
                streams.
                The <code>Collectors</code> API is intimidating: it has thirty-nine methods, some of which have as many
                as
                five type parameters. The good news is that you can derive most of the benefit from this API without
                delving
                into its full complexity. For starters, you can ignore the <code>Collector</code> interface and think of
                a
                collector as an opaque object that encapsulates a reduction strategy. In this context, reduction means
                combining the elements of a stream into a single object. The object produced by a collector is typically
                a
                collection (which accounts for the name collector).</p>

            <p>The collectors for gathering the elements of a stream into a true <code>Collection</code> are
                straightforward. There are three such collectors: <code>toList()</code>, <code>toSet()</code>, and
                <code>toCollection(collectionFactory)</code>. They return, respectively, a set, a list, and a
                programmer-specified collection type. Armed with this knowledge, we can write a stream pipeline to
                extract a
                top-ten list from our frequency table.
            </p>
            <pre><code class="language-java hljs">    <span class="hljs-comment">// Pipeline to get a top-ten list of words from a frequency table</span>
    <span class="hljs-type">List</span> <span class="hljs-variable">topTen</span> <span class="hljs-operator">=</span> freq.keySet().stream()
        .sorted(comparing(freq::get).reversed())
        .limit(<span class="hljs-number">10</span>)
        .collect(toList());      </code></pre>

            <p>Note that we haven’t qualified the <code>toList</code> method with its class, <code>Collectors</code>. It
                is
                customary and wise to statically import all members of <code>Collectors</code> because it makes stream
                pipelines more readable.</p>

            <p>The only tricky part of this code is the comparator that we pass to <code>sorted</code>,
                <code>comparing(freq::get).reversed()</code>. The <code>comparing</code> method is a comparator
                construction
                method (<strong>Item 14</strong>) that takes a key extraction function. The function takes a word, and
                the
                “extraction” is actually a table lookup: the bound method reference <code>freq::get</code> looks up the
                word
                in the frequency table and returns the number of times the word appears in the file. Finally, we call
                <code>reversed</code> on the comparator, so we’re sorting the words from most frequent to least
                frequent.
                Then it’s a simple matter to limit the stream to ten words and collect them into a list.
            </p>

            <p>The previous code snippets use <code>Scanner</code>’s <code>stream</code> method to get a stream over the
                scanner. This method was added in Java 9. If you’re using an earlier release, you can translate the
                scanner,
                which implements <code>Iterator</code>, into a stream using an adapter similar to the one in
                <strong>Item
                    47</strong> (<code>streamOf(Iterable&lt;E&gt;)</code>).
            </p>

            <p>So what about the other thirty-six methods in <code>Collectors</code>? Most of them exist to let you
                collect
                streams into maps, which is far more complicated than collecting them into true collections. Each stream
                element is associated with a key and a value, and multiple stream elements can be associated with the
                same
                key. The simplest map collector is <code>toMap(keyMapper, valueMapper)</code>, which takes two
                functions,
                one of which maps a stream element to a key, the other, to a value. We used this collector in our
                <code>fromString</code> implementation in <strong>Item 34</strong> to make a map from the string form of
                an
                enum to the enum itself:
            </p>
            <pre><code class="language-java hljs">    <span class="hljs-comment">// Using a toMap collector to make a map from string to enum</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Map</span> <span class="hljs-variable">stringToEnum</span> <span class="hljs-operator">=</span> Stream.of(values()).collect(toMap(Object::toString, e -&gt; e));  </code></pre>

            <p>This simple form of <code>toMap</code> is perfect if each element in the stream maps to a unique key. If
                multiple stream elements map to the same key, the pipeline will terminate with an
                <code>IllegalStateException</code>.
            </p>

            <p>The more complicated forms of <code>toMap</code>, as well as the <code>groupingBy</code> method, give you
                various ways to provide strategies for dealing with such collisions. One way is to provide the
                <code>toMap</code> method with a merge function in addition to its key and value mappers. The merge
                function
                is a <code>BinaryOperator&lt;V&gt;</code>, where <code>V</code> is the value type of the map. Any
                additional
                values associated with a key are combined with the existing value using the merge function, so, for
                example,
                if the merge function is multiplication, you end up with a value that is the product of all the values
                associated with the key by the value mapper.
            </p>

            <p>The three-argument form of <code>toMap</code> is also useful to make a map from a key to a chosen element
                associated with that key. For example, suppose we have a stream of record albums by various artists, and
                we
                want a map from recording artist to best-selling album. This collector will do the job.</p>
            <pre><code class="language-java hljs">    <span class="hljs-comment">// Collector to generate a map from key to chosen element for key</span>
    Map&lt;Artist, Album&gt; topHits = albums.collect(toMap(Album::artist, a-&gt;a, maxBy(comparing(Album::sales))));   </code></pre>

            <p><strong>Note:</strong> that the comparator uses the static factory method <code>maxBy</code>, which is
                statically imported from <code>BinaryOperator</code>. This method converts a
                <code>Comparator&lt;T&gt;</code> into a <code>BinaryOperator&lt;T&gt;</code> that computes the maximum
                implied by the specified comparator. In this case, the comparator is returned by the comparator
                construction
                method <code>comparing</code>, which takes the key extractor function <code>Album::sales</code>.
            </p>

            <p>This may seem a bit convoluted, but the code reads nicely. Loosely speaking, it says, “convert the stream
                of
                albums to a map, mapping each artist to the album that has the best album by sales.” This is
                surprisingly
                close to the problem statement.</p>

            <p>Another use of the three-argument form of <code>toMap</code> is to produce a collector that imposes a
                last-write-wins policy when there are collisions. For many streams, the results will be
                nondeterministic,
                but if all the values that may be associated with a key by the mapping functions are identical, or if
                they
                are all acceptable, this collector’s behavior may be just what you want:</p>
            <pre><code class="language-java hljs">    <span class="hljs-comment">// Collector to impose last-write-wins policy</span>
    toMap(keyMapper, valueMapper, (v1, v2) -&gt; v2)</code></pre>

            <p>The third and final version of <code>toMap</code> takes a fourth argument, which is a map factory, for
                use
                when you want to specify a particular map implementation such as an <code>EnumMap</code> or a
                <code>TreeMap</code>.
            </p>

            <p>There are also variant forms of the first three versions of <code>toMap</code>, named
                <code>toConcurrentMap</code>, that run efficiently in parallel and produce
                <code>ConcurrentHashMap</code>
                instances.
            </p>

            <p>In addition to the <code>toMap</code> method, the <code>Collectors</code> API provides the
                <code>groupingBy</code> method, which returns collectors to produce maps that group elements into
                categories
                based on a classifier function. The classifier function takes an element and returns the category into
                which
                it falls. This category serves as the element’s map key. The simplest version of the
                <code>groupingBy</code>
                method takes only a classifier and returns a map whose values are lists of all the elements in each
                category. This is the collector that we used in the Anagram program in <strong>Item 45</strong> to
                generate
                a map from alphabetized word to a list of the words sharing the alphabetization:
            </p>
            <pre><code class="language-java hljs">    words.collect(groupingBy(word -&gt; alphabetize(word))) </code></pre>

            <p>If you want <code>groupingBy</code> to return a collector that produces a map with values other than
                lists,
                you can specify a downstream collector in addition to a classifier. A downstream collector produces a
                value
                from a stream containing all the elements in a category. The simplest use of this parameter is to pass
                <code>toSet()</code>, which results in a map whose values are sets of elements rather than lists.
                Alternatively, you can pass <code>toCollection(collectionFactory)</code>, which lets you create the
                collections into which each category of elements is placed. This gives you the flexibility to choose any
                collection type you want. Another simple use of the two-argument form of <code>groupingBy</code> is to
                pass
                <code>counting()</code> as the downstream collector. This results in a map that associates each category
                with the number of elements in the category, rather than a collection containing the elements.
            </p>

            <p>That’s what you saw in the frequency table example at the beginning of this item:</p>
            <pre><code class="language-java hljs">    Map&lt;String, Long&gt; freq = words.collect(groupingBy(String::toLowerCase, counting()));</code></pre>

            <p>The third version of <code>groupingBy</code> lets you specify a map factory in addition to a downstream
                collector. Note that this method violates the standard telescoping argument list pattern: the
                <code>mapFactory</code> parameter precedes, rather than follows, the <code>downStream</code> parameter.
                This
                version of <code>groupingBy</code> gives you control over the containing map as well as the contained
                collections, so, for example, you can specify a collector that returns a <code>TreeMap</code> whose
                values
                are <code>TreeSet</code>s.
            </p>

            <p>The <code>groupingByConcurrent</code> method provides variants of all three overloadings of
                <code>groupingBy</code>. These variants run efficiently in parallel and produce
                <code>ConcurrentHashMap</code> instances.
            </p>

            <p>There is also a rarely used relative of <code>groupingBy</code> called <code>partitioningBy</code>. In
                lieu
                of a classifier method, it takes a predicate and returns a map whose key is a <code>Boolean</code>.
                There
                are two overloadings of this method, one of which takes a downstream collector in addition to a
                predicate.
            </p>

            <p>The collectors returned by the <code>counting</code> method are intended only for use as downstream
                collectors. The same functionality is available directly on <code>Stream</code>, via the
                <code>count</code>
                method, so there is never a reason to say <code>collect(counting())</code>. There are fifteen more
                <code>Collectors</code> methods with this property. They include the nine methods whose names begin with
                <code>summing</code>, <code>averaging</code>, and <code>summarizing</code> (whose functionality is
                available
                on the corresponding primitive stream types). They also include all overloadings of the
                <code>reducing</code> method, and the <code>filtering</code>, <code>mapping</code>,
                <code>flatMapping</code>, and <code>collectingAndThen</code> methods. Most programmers can safely ignore
                the
                majority of these methods. From a design perspective, these collectors represent an attempt to partially
                duplicate the functionality of streams in collectors so that downstream collectors can act as “mini
                streams.”
            </p>

            <p>There are three <code>Collectors</code> methods we have yet to mention. Though they are in
                <code>Collectors</code>, they don’t involve collections. The first two are <code>minBy</code> and
                <code>maxBy</code>, which take a comparator and return the minimum or maximum element in the stream as
                determined by the comparator. They are the collector analogues of the binary operators returned by the
                like-named methods in <code>BinaryOperator</code>. Recall that we used <code>BinaryOperator.maxBy</code>
                in
                our best-selling album example.
            </p>

            <p>The final <code>Collectors</code> method is <code>joining</code>, which operates only on streams of
                <code>CharSequence</code> instances such as strings. In its parameterless form, it returns a collector
                that
                simply concatenates the elements. Its one-argument form takes a single <code>CharSequence</code>
                parameter
                named <code>delimiter</code> and returns a collector that joins the stream elements, inserting the
                delimiter
                between adjacent elements. If you pass in a comma as the delimiter, the collector returns a
                comma-separated
                values string (but beware that the string will be ambiguous if any of the elements in the stream contain
                commas). The three-argument form takes a prefix and suffix in addition to the delimiter. The resulting
                collector generates strings like the ones that you get when you print a collection, for example
                <code>[came, saw, conquered]</code>.
            </p>

            <p>In summary, the essence of programming stream pipelines is side-effect-free function objects. This
                applies to
                all of the many function objects passed to streams and related objects. The terminal operation
                <code>forEach</code> should only be used to report the result of a computation performed by a stream,
                not to
                perform the computation. In order to use streams properly, you have to know about collectors. The most
                important collector factories are <code>toList</code>, <code>toSet</code>, <code>toMap</code>,
                <code>groupingBy</code>, and <code>joining</code>.
            </p>
        </div>
        <!-- item 47 -->
        <div>
            <h1>Item 47: Prefer Collection to Stream as a return type</h1>

            <p>Many methods return sequences of elements. Prior to Java 8, the obvious return types for such methods
                were
                the collection interfaces <code>Collection</code>, <code>Set</code>, and <code>List</code>;
                <code>Iterable</code>; and the array types. Usually, it was easy to decide which of these types to
                return.
                The norm was a collection interface. If the method existed solely to enable for-each loops or the
                returned
                sequence couldn’t be made to implement some Collection method (typically,
                <code>contains(Object)</code>),
                the <code>Iterable</code> interface was used. If the returned elements were primitive values or there
                were
                stringent performance requirements, arrays were used. In Java 8, streams were added to the platform,
                substantially complicating the task of choosing the appropriate return type for a sequence-returning
                method.
            </p>

            <p>You may hear it said that streams are now the obvious choice to return a sequence of elements, but as
                discussed in <strong>Item 45</strong>, streams do not make iteration obsolete: writing good code
                requires
                combining streams and iteration judiciously. If an API returns only a stream and some users want to
                iterate
                over the returned sequence with a for-each loop, those users will be justifiably upset. It is especially
                frustrating because the <code>Stream</code> interface contains the sole abstract method in the
                <code>Iterable</code> interface, and <code>Stream</code>’s specification for this method is compatible
                with
                <code>Iterable</code>’s. The only thing preventing programmers from using a for-each loop to iterate
                over a
                stream is <code>Stream</code>’s failure to extend <code>Iterable</code>.
            </p>

            <p>Sadly, there is no good workaround for this problem. At first glance, it might appear that passing a
                method
                reference to <code>Stream</code>’s <code>iterator</code> method would work. The resulting code is
                perhaps a
                bit noisy and opaque, but not unreasonable:</p>
            <pre><code class="language-java hljs">        <span class="hljs-comment">// Won't compile, due to limitations on Java's type inference</span>
        <span class="hljs-keyword">for</span> (ProcessHandle ph : ProcessHandle.allProcesses()::iterator) {
            <span class="hljs-comment">// Process the process</span>
        }</code></pre>

            <p>Unfortunately, if you attempt to compile this code, you’ll get an error message:</p>
            <pre><code class="language-java hljs">        Test.java:<span class="hljs-number">6</span>: error: method reference not expected here
        <span class="hljs-title function_">for</span> <span class="hljs-params">(ProcessHandle ph : ProcessHandle.allProcesses()</span>::iterator) {
        ^</code></pre>

            <p>In order to make the code compile, you have to cast the method reference to an appropriately
                parameterized
                <code>Iterable</code>:
            </p>
            <pre><code class="language-java hljs">        <span class="hljs-comment">// Hideous workaround to iterate over a stream</span>
        <span class="hljs-keyword">for</span> (ProcessHandle ph : (Iterable&lt;ProcessHandle&gt;)
            ProcessHandle.allProcesses()::iterator)</code></pre>

            <p>This client code works, but it is too noisy and opaque to use in practice. A better workaround is to use
                an
                adapter method. The JDK does not provide such a method, but it’s easy to write one, using the same
                technique
                used in-line in the snippets above. Note that no cast is necessary in the adapter method because Java’s
                type
                inference works properly in this context:</p>
            <pre><code class="language-java hljs">        <span class="hljs-comment">// Adapter from Stream&lt;E&gt; to Iterable&lt;E&gt;</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; Iterable&lt;E&gt; <span class="hljs-title function_">iterableOf</span><span class="hljs-params">(Stream&lt;E&gt; stream)</span> {
            <span class="hljs-keyword">return</span> stream::iterator;
        }</code></pre>

            <p>With this adapter, you can iterate over any stream with a for-each statement:</p>
            <pre><code class="language-java hljs">        <span class="hljs-keyword">for</span> (ProcessHandle p : iterableOf(ProcessHandle.allProcesses())) {
            <span class="hljs-comment">// Process the process</span>
        }</code></pre>

            <p>Note that the stream versions of the Anagrams program in <strong>Item 34</strong> use the
                <code>Files.lines</code> method to read the dictionary, while the iterative version uses a scanner. The
                <code>Files.lines</code> method is superior to a scanner, which silently swallows any exceptions
                encountered
                while reading the file. Ideally, we would have used <code>Files.lines</code> in the iterative version
                too.
                This is the sort of compromise that programmers will make if an API provides only stream access to a
                sequence and they want to iterate over the sequence with a for-each statement.
            </p>

            <p>Conversely, a programmer who wants to process a sequence using a stream pipeline will be justifiably
                upset by
                an API that provides only an <code>Iterable</code>. Again, the JDK does not provide an adapter, but it’s
                easy enough to write one:</p>
            <pre><code class="language-java hljs">        <span class="hljs-comment">// Adapter from Iterable&lt;E&gt; to Stream&lt;E&gt;</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; Stream&lt;E&gt; <span class="hljs-title function_">streamOf</span><span class="hljs-params">(Iterable&lt;E&gt; iterable)</span> {
            <span class="hljs-keyword">return</span> StreamSupport.stream(iterable.spliterator(), <span class="hljs-literal">false</span>);
        }</code></pre>

            <p>If you’re writing a method that returns a sequence of objects and you know that it will only be used in a
                stream pipeline, then of course you should feel free to return a stream. Similarly, a method returning a
                sequence that will only be used for iteration should return an <code>Iterable</code>. But if you’re
                writing
                a public API that returns a sequence, you should provide for users who want to write stream pipelines as
                well as those who want to write for-each statements, unless you have a good reason to believe that most
                of
                your users will want to use the same mechanism.</p>

            <p>The <code>Collection</code> interface is a subtype of <code>Iterable</code> and has a <code>stream</code>
                method, so it provides for both iteration and stream access. Therefore, <code>Collection</code> or an
                appropriate subtype is generally the best return type for a public, sequence-returning method. Arrays
                also
                provide for easy iteration and stream access with the <code>Arrays.asList</code> and
                <code>Stream.of</code>
                methods. If the sequence you’re returning is small enough to fit easily in memory, you’re probably best
                off
                returning one of the standard collection implementations, such as <code>ArrayList</code> or
                <code>HashSet</code>. But do not store a large sequence in memory just to return it as a collection.
            </p>

            <p>If the sequence you’re returning is large but can be represented concisely, consider implementing a
                special-purpose collection. For example, suppose you want to return the power set of a given set, which
                consists of all of its subsets. The power set of {a, b, c} is {{}, {a}, {b}, {c}, {a, b}, {a, c}, {b,
                c},
                {a, b, c}}. If a set has n elements, its power set has 2<sup>n</sup>. Therefore, you shouldn’t even
                consider
                storing the power set in a standard collection implementation. It is, however, easy to implement a
                custom
                collection for the job with the help of <code>AbstractList</code>.</p>
            <pre><code class="language-java hljs">        <span class="hljs-comment">// Returns the power set of an input set as custom collection</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PowerSet</span> {
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;E&gt; Collection&lt;Set&lt;E&gt;&gt; <span class="hljs-title function_">of</span><span class="hljs-params">(Set&lt;E&gt; s)</span> {
                List&lt;E&gt; src = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(s);
                <span class="hljs-keyword">if</span> (src.size() &gt; <span class="hljs-number">30</span>)
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"Set too big "</span> + s);
                <span class="hljs-keyword" style="font-family: JetBrains Mono, monospace;">return</span><span style="font-family: JetBrains Mono, monospace;"> </span><span class="hljs-keyword" style="font-family: JetBrains Mono, monospace;">new</span><span style="font-family: JetBrains Mono, monospace;"> </span><span class="hljs-title class_" style="font-family: JetBrains Mono, monospace;">AbstractList</span><span style="font-family: JetBrains Mono, monospace;">&lt;Set&lt;E&gt;&gt;() {</span></code><code class="language-java hljs">                    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> {
                        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> &lt;&lt; src.size(); <span class="hljs-comment">// 2 to the power srcSize</span>
                    }</code><code class="language-java hljs">                    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span> {
                        <span class="hljs-keyword">return</span> o <span class="hljs-keyword">instanceof</span> Set &amp;&amp; src.containsAll((Set)o);
                    }</code><code class="language-java hljs">                    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> Set&lt;E&gt; <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> {
                        Set&lt;E&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();
                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; index != <span class="hljs-number">0</span>; i++, index &gt;&gt;= <span class="hljs-number">1</span>)
                            <span class="hljs-keyword">if</span> ((index &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)
                                result.add(src.get(i));
                        <span class="hljs-keyword">return</span> result;
                    }
                };
            }
        }</code></pre>

            <p>Note that <code>PowerSet.of</code> throws an exception if the input set has more than 30 elements. This
                highlights a disadvantage of using <code>Collection</code> as a return type rather than
                <code>Stream</code>
                or <code>Iterable</code>: <code>Collection</code> has an <code>int</code>-returning <code>size</code>
                method, which limits the length of the returned sequence to <code>Integer.MAX_VALUE</code>, or
                2<sup>31</sup> − 1. The <code>Collection</code> specification does allow the <code>size</code> method to
                return 2<sup>31</sup> − 1 if the collection is larger, even infinite, but this is not a wholly
                satisfying
                solution.
            </p>

            <p>In order to write a <code>Collection</code> implementation atop <code>AbstractCollection</code>, you need
                implement only two methods beyond the one required for <code>Iterable</code>: <code>contains</code> and
                <code>size</code>. Often it’s easy to write efficient implementations of these methods. If it isn’t
                feasible, perhaps because the contents of the sequence aren’t predetermined before iteration takes
                place,
                return a stream or iterable, whichever feels more natural. If you choose, you can return both using two
                separate methods.
            </p>

            <p>There are times when you’ll choose the return type based solely on ease of implementation. For example,
                suppose you want to write a method that returns all of the (contiguous) sublists of an input list. It
                takes
                only three lines of code to generate these sublists and put them in a standard collection, but the
                memory
                required to hold this collection is quadratic in the size of the source list. While this is not as bad
                as
                the power set, which is exponential, it is clearly unacceptable.</p>

            <p>Implementing a custom collection, as we did for the power set, would be tedious, more so because the JDK
                lacks a skeletal <code>Iterator</code> implementation to help us. It is, however, straightforward to
                implement a stream of all the sublists of an input list, though it does require a minor insight. Let’s
                call
                a sublist that contains the first element of a list a prefix of the list. For example, the prefixes of
                (a,
                b, c) are (a), (a, b), and (a, b, c). Similarly, let’s call a sublist that contains the last element a
                suffix, so the suffixes of (a, b, c) are (a, b, c), (b, c), and (c). The insight is that the sublists of
                a
                list are simply the suffixes of the prefixes (or identically, the prefixes of the suffixes) and the
                empty
                list. This observation leads directly to a clear, reasonably concise implementation:</p>
            <pre><code class="language-java hljs">        <span class="hljs-comment">// Returns a stream of all the sublists of its input list</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubLists</span> {
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; Stream&lt;List&lt;E&gt;&gt; <span class="hljs-title function_">of</span><span class="hljs-params">(List&lt;E&gt; list)</span> {
                <span class="hljs-keyword">return</span> Stream.concat(Stream.of(Collections.emptyList()), prefixes(list).flatMap(SubLists::suffixes));
            }
            <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;E&gt; Stream&lt;List&lt;E&gt;&gt; <span class="hljs-title function_">prefixes</span><span class="hljs-params">(List&lt;E&gt; list)</span> {
                <span class="hljs-keyword">return</span> IntStream.rangeClosed(<span class="hljs-number">1</span>, list.size()).mapToObj(end -&gt; list.subList(<span class="hljs-number">0</span>, end));
            }
            <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;E&gt; Stream&lt;List&lt;E&gt;&gt; <span class="hljs-title function_">suffixes</span><span class="hljs-params">(List&lt;E&gt; list)</span> {
                <span class="hljs-keyword">return</span> IntStream.range(<span class="hljs-number">0</span>, list.size()).mapToObj(start -&gt; list.subList(start, list.size()));
            }
        }</code></pre>

            <p>Note that the <code>Stream.concat</code> method is used to add the empty list into the returned stream.
                Also
                note that the <code>flatMap</code> method (<strong>Item 45</strong>) is used to generate a single stream
                consisting of all the suffixes of all the prefixes. Finally, note that we generate the prefixes and
                suffixes
                by mapping a stream of consecutive <code>int</code> values returned by <code>IntStream.range</code> and
                <code>IntStream.rangeClosed</code>. This idiom is, roughly speaking, the stream equivalent of the
                standard
                for-loop on integer indices. Thus, our sublist implementation is similar in spirit to the obvious nested
                for-loop:
            </p>
            <pre><code class="language-java hljs">        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; start &lt; src.size(); start++)
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> start + <span class="hljs-number">1</span>; end &lt;= src.size(); end++)
                System.out.println(src.subList(start, end));</code></pre>

            <p>It is possible to translate this for-loop directly into a stream. The result is more concise than our
                previous implementation, but perhaps a bit less readable. It is similar in spirit to the streams code
                for
                the Cartesian product in <strong>Item 45</strong>:</p>
            <pre><code class="language-java hljs">        <span class="hljs-comment">// Returns a stream of all the sublists of its input list</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; Stream&lt;List&lt;E&gt;&gt; <span class="hljs-title function_">of</span><span class="hljs-params">(List&lt;E&gt; list)</span> {
            <span class="hljs-keyword">return</span> IntStream.range(<span class="hljs-number">0</span>, list.size())
                .mapToObj(start -&gt; IntStream.rangeClosed(start + <span class="hljs-number">1</span>, list.size()).mapToObj(end -&gt; list.subList(start, end)))
                .flatMap(x -&gt; x);
        }</code></pre>

            <p>Like the for-loop that precedes it, this code does not emit the empty list. In order to fix this
                deficiency,
                you could either use <code>concat</code>, as we did in the previous version, or replace 1 by (int)
                Math.signum(start) in the <code>rangeClosed</code> call.</p>

            <p>Either of these stream implementations of sublists is fine, but both will require some users to employ a
                Stream-to-Iterable adapter or to use a stream in places where iteration would be more natural. Not only
                does
                the Stream-to-Iterable adapter clutter up client code, but it slows down the loop by a factor of 2.3 on
                my
                machine. A purpose-built <code>Collection</code> implementation (not shown here) is considerably more
                verbose but runs about 1.4 times as fast as our stream-based implementation on my machine.</p>

            <p>In summary, when writing a method that returns a sequence of elements, remember that some of your users
                may
                want to process them as a stream while others may want to iterate over them. Try to accommodate both
                groups.
                If it’s feasible to return a collection, do so. If you already have the elements in a collection or the
                number of elements in the sequence is small enough to justify creating a new one, return a standard
                collection such as <code>ArrayList</code>. Otherwise, consider implementing a custom collection as we
                did
                for the power set. If it isn’t feasible to return a collection, return a stream or iterable, whichever
                seems
                more natural. If, in a future Java release, the <code>Stream</code> interface declaration is modified to
                extend <code>Iterable</code>, then you should feel free to return streams because they will allow for
                both
                stream processing and iteration.</p>
        </div>
        <!-- item 48 -->
        <div>
            <h1>Item 48: Use caution when making streams parallel</h1>

            <p>Among mainstream languages, Java has always been at the forefront of providing facilities to ease the
                task of
                concurrent programming. When Java was released in 1996, it had built-in support for threads, with
                synchronization and wait/notify. Java 5 introduced the <code>java.util.concurrent</code> library, with
                concurrent collections and the executor framework. Java 7 introduced the fork-join package, a
                high-performance framework for parallel decomposition. Java 8 introduced streams, which can be
                parallelized
                with a single call to the <code>parallel</code> method. Writing concurrent programs in Java keeps
                getting
                easier, but writing concurrent programs that are correct and fast is as difficult as it ever was. Safety
                and
                liveness violations are a fact of life in concurrent programming, and parallel stream pipelines are no
                exception.</p>

            <p>Consider this program from <strong>Item 45</strong>:</p>
            <pre><code class="language-java hljs">    <span class="hljs-comment">// Stream-based program to generate the first 20 Mersenne primes</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        primes().map(p -&gt; TWO.pow(p.intValueExact()).subtract(ONE))
            .filter(mersenne -&gt; mersenne.isProbablePrime(<span class="hljs-number">50</span>))
            .limit(<span class="hljs-number">20</span>)
            .forEach(System.out::println);
    }</code><code class="language-java hljs">    <span class="hljs-keyword">static</span> Stream&lt;BigInteger&gt; <span class="hljs-title function_">primes</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> Stream.iterate(TWO, BigInteger::nextProbablePrime);
    }</code></pre>

            <p>On my machine, this program immediately starts printing primes and takes 12.5 seconds to run to
                completion.
                Suppose I naively try to speed it up by adding a call to <code>parallel()</code> to the stream pipeline.
                What do you think will happen to its performance? Will it get a few percent faster? A few percent
                slower?
                Sadly, what happens is that it doesn’t print anything, but CPU usage spikes to 90 percent and stays
                there
                indefinitely (a liveness failure). The program might terminate eventually, but I was unwilling to find
                out;
                I stopped it forcibly after half an hour.</p>

            <p>What’s going on here? Simply put, the streams library has no idea how to parallelize this pipeline and
                the
                heuristics fail. Even under the best of circumstances, parallelizing a pipeline is unlikely to increase
                its
                performance if the source is from <code>Stream.iterate</code>, or the intermediate operation
                <code>limit</code> is used. This pipeline has to contend with both of these issues. Worse, the default
                parallelization strategy deals with the unpredictability of <code>limit</code> by assuming there’s no
                harm
                in processing a few extra elements and discarding any unneeded results. In this case, it takes roughly
                twice
                as long to find each Mersenne prime as it did to find the previous one. Thus, the cost of computing a
                single
                extra element is roughly equal to the cost of computing all previous elements combined, and this
                innocuous-looking pipeline brings the automatic parallelization algorithm to its knees. The moral of
                this
                story is simple: Do not parallelize stream pipelines indiscriminately. The performance consequences may
                be
                disastrous.
            </p>

            <p>As a rule, performance gains from parallelism are best on streams over <code>ArrayList</code>,
                <code>HashMap</code>, <code>HashSet</code>, and <code>ConcurrentHashMap</code> instances; arrays;
                <code>int</code> ranges; and <code>long</code> ranges. What these data structures have in common is that
                they can all be accurately and cheaply split into subranges of any desired sizes, which makes it easy to
                divide work among parallel threads. The abstraction used by the streams library to perform this task is
                the
                <code>Spliterator</code>, which is returned by the <code>spliterator</code> method on
                <code>Stream</code>
                and <code>Iterable</code>.
            </p>

            <p>Another important factor that all of these data structures have in common is that they provide
                good-to-excellent locality of reference when processed sequentially: sequential element references are
                stored together in memory. The objects referred to by those references may not be close to one another
                in
                memory, which reduces locality-of-reference. Locality-of-reference turns out to be critically important
                for
                parallelizing bulk operations: without it, threads spend much of their time idle, waiting for data to be
                transferred from memory into the processor’s cache. The data structures with the best locality of
                reference
                are primitive arrays because the data itself is stored contiguously in memory.</p>

            <p>The nature of a stream pipeline’s terminal operation also affects the effectiveness of parallel
                execution. If
                a significant amount of work is done in the terminal operation compared to the overall work of the
                pipeline
                and that operation is inherently sequential, then parallelizing the pipeline will have limited
                effectiveness. The best terminal operations for parallelism are reductions, where all of the elements
                emerging from the pipeline are combined using one of Stream’s <code>reduce</code> methods, or
                prepackaged
                reductions such as <code>min</code>, <code>max</code>, <code>count</code>, and <code>sum</code>. The
                short-circuiting operations <code>anyMatch</code>, <code>allMatch</code>, and <code>noneMatch</code> are
                also amenable to parallelism. The operations performed by Stream’s <code>collect</code> method, which
                are
                known as mutable reductions, are not good candidates for parallelism because the overhead of combining
                collections is costly.</p>

            <p>If you write your own Stream, Iterable, or Collection implementation and you want decent parallel
                performance, you must override the <code>spliterator</code> method and test the parallel performance of
                the
                resulting streams extensively. Writing high-quality spliterators is difficult and beyond the scope of
                this
                book.</p>

            <p>Not only can parallelizing a stream lead to poor performance, including liveness failures; it can lead to
                incorrect results and unpredictable behavior (safety failures). Safety failures may result from
                parallelizing a pipeline that uses mappers, filters, and other programmer-supplied function objects that
                fail to adhere to their specifications. The Stream specification places stringent requirements on these
                function objects. For example, the accumulator and combiner functions passed to Stream’s
                <code>reduce</code>
                operation must be associative, non-interfering, and stateless. If you violate these requirements (some
                of
                which are discussed in <strong>Item 46</strong>) but run your pipeline sequentially, it will likely
                yield
                correct results; if you parallelize it, it will likely fail, perhaps catastrophically.
            </p>

            <p>Along these lines, it’s worth noting that even if the parallelized Mersenne primes program had run to
                completion, it would not have printed the primes in the correct (ascending) order. To preserve the order
                displayed by the sequential version, you’d have to replace the <code>forEach</code> terminal operation
                with
                <code>forEachOrdered</code>, which is guaranteed to traverse parallel streams in encounter order.
            </p>

            <p>Even assuming that you’re using an efficiently splittable source stream, a parallelizable or cheap
                terminal
                operation, and non-interfering function objects, you won’t get a good speedup from parallelization
                unless
                the pipeline is doing enough real work to offset the costs associated with parallelism. As a very rough
                estimate, the number of elements in the stream times the number of lines of code executed per element
                should
                be at least a hundred thousand [Lea14].</p>

            <p>It’s important to remember that parallelizing a stream is strictly a performance optimization. As is the
                case
                for any optimization, you must test the performance before and after the change to ensure that it is
                worth
                doing (<strong>Item 67</strong>). Ideally, you should perform the test in a realistic system setting.
                Normally, all parallel stream pipelines in a program run in a common fork-join pool. A single
                misbehaving
                pipeline can harm the performance of others in unrelated parts of the system.</p>

            <p>If it sounds like the odds are stacked against you when parallelizing stream pipelines, it’s because they
                are. An acquaintance who maintains a multimillion-line codebase that makes heavy use of streams found
                only a
                handful of places where parallel streams were effective. This does not mean that you should refrain from
                parallelizing streams. Under the right circumstances, it is possible to achieve near-linear speedup in
                the
                number of processor cores simply by adding a <code>parallel</code> call to a stream pipeline. Certain
                domains, such as machine learning and data processing, are particularly amenable to these speedups.</p>

            <p>As a simple example of a stream pipeline where parallelism is effective, consider this function for
                computing
                <code>π(n)</code>, the number of primes less than or equal to <code>n</code>:
            </p>
            <pre><code class="language-java hljs">    <span class="hljs-comment">// Prime-counting stream pipeline - benefits from parallelization</span>
    <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">pi</span><span class="hljs-params">(<span class="hljs-type">long</span> n)</span> {
        <span class="hljs-keyword">return</span> LongStream.rangeClosed(<span class="hljs-number">2</span>, n)
            .mapToObj(BigInteger::valueOf)
            .filter(i -&gt; i.isProbablePrime(<span class="hljs-number">50</span>))
            .count();
    }</code></pre>

            <p>On my machine, it takes 31 seconds to compute <code>π(10<sup>8</sup>)</code> using this function. Simply
                adding a <code>parallel()</code> call reduces the time to 9.2 seconds:</p>
            <pre><code class="language-java hljs">    <span class="hljs-comment">// Prime-counting stream pipeline - parallel version</span>
    <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">pi</span><span class="hljs-params">(<span class="hljs-type">long</span> n)</span> {
        <span class="hljs-keyword">return</span> LongStream.rangeClosed(<span class="hljs-number">2</span>, n)
            .parallel()
            .mapToObj(BigInteger::valueOf)
            .filter(i -&gt; i.isProbablePrime(<span class="hljs-number">50</span>))
            .count();
    }</code></pre>

            <p>In other words, parallelizing the computation speeds it up by a factor of 3.7 on my quad-core machine.
                It’s
                worth noting that this is not how you’d compute <code>π(n)</code> for large values of <code>n</code> in
                practice. There are far more efficient algorithms, notably Lehmer’s formula.</p>

            <p>If you are going to parallelize a stream of random numbers, start with a <code>SplittableRandom</code>
                instance rather than a <code>ThreadLocalRandom</code> (or the essentially obsolete <code>Random</code>).
                <code>SplittableRandom</code> is designed for precisely this use, and has the potential for linear
                speedup.
                <code>ThreadLocalRandom</code> is designed for use by a single thread, and will adapt itself to function
                as
                a parallel stream source, but won’t be as fast as <code>SplittableRandom</code>. <code>Random</code>
                synchronizes on every operation, so it will result in excessive, parallelism-killing contention.
            </p>

            <p>In summary, do not even attempt to parallelize a stream pipeline unless you have good reason to believe
                that
                it will preserve the correctness of the computation and increase its speed. The cost of inappropriately
                parallelizing a stream can be a program failure or performance disaster. If you believe that parallelism
                may
                be justified, ensure that your code remains correct when run in parallel, and do careful performance
                measurements under realistic conditions. If your code remains correct and these experiments bear out
                your
                suspicion of increased performance, then and only then parallelize the stream in production code.</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <script src="script.js"></script>
</body>