<div>
    <h1>CHAPTER 8: Methods</h1>

    <p>
        THIS chapter discusses several aspects of method design: how to treat parameters and return values, how to
        design method signatures, and how to document methods. Much of the material in this chapter applies to
        constructors as well as to methods. Like Chapter 4, this chapter focuses on usability, robustness, and
        flexibility.
    </p>

    <h1>Item 49: Check parameters for validity</h1>

    <p>
        Most methods and constructors have some restrictions on what values may be passed into their parameters. For
        example, it is not uncommon that index values must be non-negative and object references must be non-null. You
        should clearly document all such restrictions and enforce them with checks at the beginning of the method body.
        This is a special case of the general principle that you should attempt to detect errors as soon as possible
        after they occur. Failing to do so makes it less likely that an error will be detected and makes it harder to
        determine the source of an error once it has been detected.
    </p>

    <p>
        If an invalid parameter value is passed to a method and the method checks its parameters before execution, it
        will fail quickly and cleanly with an appropriate exception. If the method fails to check its parameters,
        several things could happen. The method could fail with a confusing exception in the midst of processing. Worse,
        the method could return normally but silently compute the wrong result. Worst of all, the method could return
        normally but leave some object in a compromised state, causing an error at some unrelated point in the code at
        some undetermined time in the future. In other words, failure to validate parameters can result in a violation
        of failure atomicity (Item 76).
    </p>

    <p>
        For public and protected methods, use the Javadoc <code>@throws</code> tag to document the exception that will
        be thrown if a restriction on parameter values is violated (Item 74). Typically, the resulting exception will be
        <code>IllegalArgumentException</code>, <code>IndexOutOfBoundsException</code>, or
        <code>NullPointerException</code> (Item 72). Once you’ve documented the restrictions on a method’s parameters
        and you’ve documented the exceptions that will be thrown if these restrictions are violated, it is a simple
        matter to enforce the restrictions. Here’s a typical example:
    </p>

    <pre><code class="language-java hljs">
<span class="hljs-comment">/**
 * Returns a BigInteger whose value is (this mod m). This method
 * differs from the remainder method in that it always returns a
 * non-negative BigInteger.
 *
 * <span class="hljs-doctag">@param</span> m the modulus, which must be positive
 * <span class="hljs-doctag">@return</span> this mod m
 * <span class="hljs-doctag">@throws</span> ArithmeticException if m is less than or equal to 0
 */</span>
<span class="hljs-keyword">public</span> BigInteger <span class="hljs-title function_">mod</span><span class="hljs-params">(BigInteger m)</span> {
    <span class="hljs-keyword">if</span> (m.signum() &lt;= <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArithmeticException</span>(<span class="hljs-string">"Modulus &lt;= 0: "</span> + m);
    }
    <span class="hljs-comment">// Do the computation</span>
}
    </code></pre>

    <p>
        Note that the doc comment does not say “mod throws NullPointerException if m is null,” even though the method
        does exactly that, as a byproduct of invoking <code>m.signum()</code>. This exception is documented in the
        class-level doc comment for the enclosing <code>BigInteger</code> class. The class-level comment applies to all
        parameters in all of the class’s public methods. This is a good way to avoid the clutter of documenting every
        <code>NullPointerException</code> on every method individually. It may be combined with the use of
        <code>@Nullable</code> or a similar annotation to indicate that a particular parameter may be null, but this
        practice is not standard, and multiple annotations are in use for this purpose.
    </p>

    <p>
        The <code>Objects.requireNonNull</code> method, added in Java 7, is flexible and convenient, so there’s no
        reason to perform null checks manually anymore. You can specify your own exception detail message if you wish.
        The method returns its input, so you can perform a null check at the same time as you use a value:
    </p>

    <pre><code class="language-java hljs">
<span class="hljs-comment">// Inline use of Java's null-checking facility</span>
<span class="hljs-built_in">this</span>.strategy = Objects.requireNonNull(strategy, <span class="hljs-string">"strategy"</span>);
    </code></pre>

    <p>
        You can also ignore the return value and use <code>Objects.requireNonNull</code> as a freestanding null check
        where that suits your needs.
    </p>

    <p>
        In Java 9, a range-checking facility was added to <code>java.util.Objects</code>. This facility consists of
        three methods: <code>checkFromIndexSize</code>, <code>checkFromToIndex</code>, and <code>checkIndex</code>. This
        facility is not as flexible as the null-checking method. It doesn’t let you specify your own exception detail
        message, and it is designed solely for use on list and array indices. It does not handle closed ranges (which
        contain both of their endpoints). But if it does what you need, it’s a useful convenience.
    </p>

    <p>
        For an unexported method, you, as the package author, control the circumstances under which the method is
        called, so you can and should ensure that only valid parameter values are ever passed in. Therefore, nonpublic
        methods can check their parameters using assertions, as shown below:
    </p>

    <pre><code class="language-java hljs">
<span class="hljs-comment">// Private helper function for a recursive sort</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">long</span>[] a, <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> length)</span> {
    <span class="hljs-keyword">assert</span> a != <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">assert</span> offset &gt;= <span class="hljs-number">0</span> &amp;&amp; offset &lt;= a.length;
    <span class="hljs-keyword">assert</span> length &gt;= <span class="hljs-number">0</span> &amp;&amp; length &lt;= a.length - offset;
    <span class="hljs-comment">// Do the computation</span>
}
    </code></pre>

    <p>
        In essence, these assertions are claims that the asserted condition will be true, regardless of how the
        enclosing package is used by its clients. Unlike normal validity checks, assertions throw
        <code>AssertionError</code> if they fail. And unlike normal validity checks, they have no effect and essentially
        no cost unless you enable them, which you do by passing the <code>-ea</code> (or <code>-enableassertions</code>)
        flag to the <code>java</code> command. For more information on assertions, see the tutorial <a
            href="https://docs.oracle.com/javase/tutorial/essential/exceptions/assert.html">[Asserts]</a>.
    </p>

    <p>
        It is particularly important to check the validity of parameters that are not used by a method, but stored for
        later use. For example, consider the static factory method on page 101, which takes an <code>int</code> array
        and returns a <code>List</code> view of the array. If a client were to pass in <code>null</code>, the method
        would throw a <code>NullPointerException</code> because the method has an explicit check (the call to
        <code>Objects.requireNonNull</code>). Had the check been omitted, the method would return a reference to a newly
        created <code>List</code> instance that would throw a <code>NullPointerException</code> as soon as a client
        attempted to use it. By that time, the origin of the <code>List</code> instance might be difficult to determine,
        which could greatly complicate the task of debugging.
    </p>

    <p>
        Constructors represent a special case of the principle that you should check the validity of parameters that are
        to be stored away for later use. It is critical to check the validity of constructor parameters to prevent the
        construction of an object that violates its class invariants.
    </p>

    <p>
        There are exceptions to the rule that you should explicitly check a method’s parameters before performing its
        computation. An important exception is the case in which the validity check would be expensive or impractical
        and the check is performed implicitly in the process of doing the computation. For example, consider a method
        that sorts a list of objects, such as <code>Collections.sort(List)</code>. All of the objects in the list must
        be mutually comparable. In the process of sorting the list, every object in the list will be compared to some
        other object in the list. If the objects aren’t mutually comparable, one of these comparisons will throw a
        <code>ClassCastException</code>, which is exactly what the sort method should do. Therefore, there would be
        little point in checking ahead of time that the elements in the list were mutually comparable. Note, however,
        that indiscriminate reliance on implicit validity checks can result in the loss of failure atomicity (Item 76).
    </p>

    <p>
        Occasionally, a computation implicitly performs a required validity check but throws the wrong exception if the
        check fails. In other words, the exception that the computation would naturally throw as the result of an
        invalid parameter value doesn’t match the exception that the method is documented to throw. Under these
        circumstances, you should use the exception translation idiom, described in Item 73, to translate the natural
        exception into the correct one.
    </p>

    <p>
        Do not infer from this item that arbitrary restrictions on parameters are a good thing. On the contrary, you
        should design methods to be as general as it is practical to make them. The fewer restrictions that you place on
        parameters, the better, assuming the method can do something reasonable with all of the parameter values that it
        accepts. Often, however, some restrictions are intrinsic to the abstraction being implemented.
    </p>

    <p>
        To summarize, each time you write a method or constructor, you should think about what restrictions exist on its
        parameters. You should document these restrictions and enforce them with explicit checks at the beginning of the
        method body. It is important to get into the habit of doing this. The modest work that it entails will be paid
        back with interest the first time a validity check fails.
    </p>
</div>