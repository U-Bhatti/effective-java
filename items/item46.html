<div>
    <h1>Item 46: Prefer side-effect-free functions in streams</h1>

    <p>If you’re new to streams, it can be difficult to get the hang of them. Merely expressing your computation
        as
        a stream pipeline can be hard. When you succeed, your program will run, but you may realize little if
        any
        benefit. Streams isn’t just an API, it’s a paradigm based on functional programming. In order to obtain
        the
        expressiveness, speed, and in some cases parallelizability that streams have to offer, you have to adopt
        the
        paradigm as well as the API.</p>

    <p>The most important part of the streams paradigm is to structure your computation as a sequence of
        transformations where the result of each stage is as close as possible to a pure function of the result
        of
        the previous stage. A pure function is one whose result depends only on its input: it does not depend on
        any
        mutable state, nor does it update any state. In order to achieve this, any function objects that you
        pass
        into stream operations, both intermediate and terminal, should be free of side-effects.</p>

    <p>Occasionally, you may see streams code that looks like this snippet, which builds a frequency table of
        the
        words in a text file:</p>
    <pre><code class="language-java hljs">    <span class="hljs-comment">// Uses the streams API but not the paradigm--Don't do this!</span>
    <span class="hljs-type">Map</span> <span class="hljs-variable">freq</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
    <span class="hljs-keyword">try</span> (<span class="hljs-type">Stream</span> <span class="hljs-variable">words</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(file).tokens()) {
        words.forEach(word -&gt; {
            freq.merge(word.toLowerCase(), <span class="hljs-number">1L</span>, Long::sum);
        });
    } </code></pre>

    <p>What’s wrong with this code? After all, it uses streams, lambdas, and method references, and gets the
        right
        answer. Simply put, it’s not streams code at all; it’s iterative code masquerading as streams code. It
        derives no benefits from the streams API, and it’s (a bit) longer, harder to read, and less maintainable
        than the corresponding iterative code. The problem stems from the fact that this code is doing all its
        work
        in a terminal <code>forEach</code> operation, using a lambda that mutates external state (the frequency
        table). A <code>forEach</code> operation that does anything more than present the result of the
        computation
        performed by a stream is a “bad smell in code,” as is a lambda that mutates state. So how should this
        code
        look?</p>
    <pre><code class="language-java hljs">    <span class="hljs-comment">// Proper use of streams to initialize a frequency table</span>
    Map freq;
    <span class="hljs-keyword">try</span> (<span class="hljs-type">Stream</span> <span class="hljs-variable">words</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(file).tokens()) {
        freq = words
            .collect(groupingBy(String::toLowerCase, counting()));
    }</code></pre>

    <p>This snippet does the same thing as the previous one but makes proper use of the streams API. It’s
        shorter
        and clearer. So why would anyone write it the other way? Because it uses tools they’re already familiar
        with. Java programmers know how to use for-each loops, and the <code>forEach</code> terminal operation
        is
        similar. But the <code>forEach</code> operation is among the least powerful of the terminal operations
        and
        the least stream-friendly. It’s explicitly iterative, and hence not amenable to parallelization. The
        <code>forEach</code> operation should be used only to report the result of a stream computation, not to
        perform the computation. Occasionally, it makes sense to use <code>forEach</code> for some other
        purpose,
        such as adding the results of a stream computation to a preexisting collection.
    </p>

    <p>The improved code uses a collector, which is a new concept that you have to learn in order to use
        streams.
        The <code>Collectors</code> API is intimidating: it has thirty-nine methods, some of which have as many
        as
        five type parameters. The good news is that you can derive most of the benefit from this API without
        delving
        into its full complexity. For starters, you can ignore the <code>Collector</code> interface and think of
        a
        collector as an opaque object that encapsulates a reduction strategy. In this context, reduction means
        combining the elements of a stream into a single object. The object produced by a collector is typically
        a
        collection (which accounts for the name collector).</p>

    <p>The collectors for gathering the elements of a stream into a true <code>Collection</code> are
        straightforward. There are three such collectors: <code>toList()</code>, <code>toSet()</code>, and
        <code>toCollection(collectionFactory)</code>. They return, respectively, a set, a list, and a
        programmer-specified collection type. Armed with this knowledge, we can write a stream pipeline to
        extract a
        top-ten list from our frequency table.
    </p>
    <pre><code class="language-java hljs">    <span class="hljs-comment">// Pipeline to get a top-ten list of words from a frequency table</span>
    <span class="hljs-type">List</span> <span class="hljs-variable">topTen</span> <span class="hljs-operator">=</span> freq.keySet().stream()
        .sorted(comparing(freq::get).reversed())
        .limit(<span class="hljs-number">10</span>)
        .collect(toList());      </code></pre>

    <p>Note that we haven’t qualified the <code>toList</code> method with its class, <code>Collectors</code>. It
        is
        customary and wise to statically import all members of <code>Collectors</code> because it makes stream
        pipelines more readable.</p>

    <p>The only tricky part of this code is the comparator that we pass to <code>sorted</code>,
        <code>comparing(freq::get).reversed()</code>. The <code>comparing</code> method is a comparator
        construction
        method (<strong>Item 14</strong>) that takes a key extraction function. The function takes a word, and
        the
        “extraction” is actually a table lookup: the bound method reference <code>freq::get</code> looks up the
        word
        in the frequency table and returns the number of times the word appears in the file. Finally, we call
        <code>reversed</code> on the comparator, so we’re sorting the words from most frequent to least
        frequent.
        Then it’s a simple matter to limit the stream to ten words and collect them into a list.
    </p>

    <p>The previous code snippets use <code>Scanner</code>’s <code>stream</code> method to get a stream over the
        scanner. This method was added in Java 9. If you’re using an earlier release, you can translate the
        scanner,
        which implements <code>Iterator</code>, into a stream using an adapter similar to the one in
        <strong>Item
            47</strong> (<code>streamOf(Iterable&lt;E&gt;)</code>).
    </p>

    <p>So what about the other thirty-six methods in <code>Collectors</code>? Most of them exist to let you
        collect
        streams into maps, which is far more complicated than collecting them into true collections. Each stream
        element is associated with a key and a value, and multiple stream elements can be associated with the
        same
        key. The simplest map collector is <code>toMap(keyMapper, valueMapper)</code>, which takes two
        functions,
        one of which maps a stream element to a key, the other, to a value. We used this collector in our
        <code>fromString</code> implementation in <strong>Item 34</strong> to make a map from the string form of
        an
        enum to the enum itself:
    </p>
    <pre><code class="language-java hljs">    <span class="hljs-comment">// Using a toMap collector to make a map from string to enum</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Map</span> <span class="hljs-variable">stringToEnum</span> <span class="hljs-operator">=</span> Stream.of(values()).collect(toMap(Object::toString, e -&gt; e));  </code></pre>

    <p>This simple form of <code>toMap</code> is perfect if each element in the stream maps to a unique key. If
        multiple stream elements map to the same key, the pipeline will terminate with an
        <code>IllegalStateException</code>.
    </p>

    <p>The more complicated forms of <code>toMap</code>, as well as the <code>groupingBy</code> method, give you
        various ways to provide strategies for dealing with such collisions. One way is to provide the
        <code>toMap</code> method with a merge function in addition to its key and value mappers. The merge
        function
        is a <code>BinaryOperator&lt;V&gt;</code>, where <code>V</code> is the value type of the map. Any
        additional
        values associated with a key are combined with the existing value using the merge function, so, for
        example,
        if the merge function is multiplication, you end up with a value that is the product of all the values
        associated with the key by the value mapper.
    </p>

    <p>The three-argument form of <code>toMap</code> is also useful to make a map from a key to a chosen element
        associated with that key. For example, suppose we have a stream of record albums by various artists, and
        we
        want a map from recording artist to best-selling album. This collector will do the job.</p>
    <pre><code class="language-java hljs">    <span class="hljs-comment">// Collector to generate a map from key to chosen element for key</span>
    Map&lt;Artist, Album&gt; topHits = albums.collect(toMap(Album::artist, a-&gt;a, maxBy(comparing(Album::sales))));   </code></pre>

    <p><strong>Note:</strong> that the comparator uses the static factory method <code>maxBy</code>, which is
        statically imported from <code>BinaryOperator</code>. This method converts a
        <code>Comparator&lt;T&gt;</code> into a <code>BinaryOperator&lt;T&gt;</code> that computes the maximum
        implied by the specified comparator. In this case, the comparator is returned by the comparator
        construction
        method <code>comparing</code>, which takes the key extractor function <code>Album::sales</code>.
    </p>

    <p>This may seem a bit convoluted, but the code reads nicely. Loosely speaking, it says, “convert the stream
        of
        albums to a map, mapping each artist to the album that has the best album by sales.” This is
        surprisingly
        close to the problem statement.</p>

    <p>Another use of the three-argument form of <code>toMap</code> is to produce a collector that imposes a
        last-write-wins policy when there are collisions. For many streams, the results will be
        nondeterministic,
        but if all the values that may be associated with a key by the mapping functions are identical, or if
        they
        are all acceptable, this collector’s behavior may be just what you want:</p>
    <pre><code class="language-java hljs">    <span class="hljs-comment">// Collector to impose last-write-wins policy</span>
    toMap(keyMapper, valueMapper, (v1, v2) -&gt; v2)</code></pre>

    <p>The third and final version of <code>toMap</code> takes a fourth argument, which is a map factory, for
        use
        when you want to specify a particular map implementation such as an <code>EnumMap</code> or a
        <code>TreeMap</code>.
    </p>

    <p>There are also variant forms of the first three versions of <code>toMap</code>, named
        <code>toConcurrentMap</code>, that run efficiently in parallel and produce
        <code>ConcurrentHashMap</code>
        instances.
    </p>

    <p>In addition to the <code>toMap</code> method, the <code>Collectors</code> API provides the
        <code>groupingBy</code> method, which returns collectors to produce maps that group elements into
        categories
        based on a classifier function. The classifier function takes an element and returns the category into
        which
        it falls. This category serves as the element’s map key. The simplest version of the
        <code>groupingBy</code>
        method takes only a classifier and returns a map whose values are lists of all the elements in each
        category. This is the collector that we used in the Anagram program in <strong>Item 45</strong> to
        generate
        a map from alphabetized word to a list of the words sharing the alphabetization:
    </p>
    <pre><code class="language-java hljs">    words.collect(groupingBy(word -&gt; alphabetize(word))) </code></pre>

    <p>If you want <code>groupingBy</code> to return a collector that produces a map with values other than
        lists,
        you can specify a downstream collector in addition to a classifier. A downstream collector produces a
        value
        from a stream containing all the elements in a category. The simplest use of this parameter is to pass
        <code>toSet()</code>, which results in a map whose values are sets of elements rather than lists.
        Alternatively, you can pass <code>toCollection(collectionFactory)</code>, which lets you create the
        collections into which each category of elements is placed. This gives you the flexibility to choose any
        collection type you want. Another simple use of the two-argument form of <code>groupingBy</code> is to
        pass
        <code>counting()</code> as the downstream collector. This results in a map that associates each category
        with the number of elements in the category, rather than a collection containing the elements.
    </p>

    <p>That’s what you saw in the frequency table example at the beginning of this item:</p>
    <pre><code class="language-java hljs">    Map&lt;String, Long&gt; freq = words.collect(groupingBy(String::toLowerCase, counting()));</code></pre>

    <p>The third version of <code>groupingBy</code> lets you specify a map factory in addition to a downstream
        collector. Note that this method violates the standard telescoping argument list pattern: the
        <code>mapFactory</code> parameter precedes, rather than follows, the <code>downStream</code> parameter.
        This
        version of <code>groupingBy</code> gives you control over the containing map as well as the contained
        collections, so, for example, you can specify a collector that returns a <code>TreeMap</code> whose
        values
        are <code>TreeSet</code>s.
    </p>

    <p>The <code>groupingByConcurrent</code> method provides variants of all three overloadings of
        <code>groupingBy</code>. These variants run efficiently in parallel and produce
        <code>ConcurrentHashMap</code> instances.
    </p>

    <p>There is also a rarely used relative of <code>groupingBy</code> called <code>partitioningBy</code>. In
        lieu
        of a classifier method, it takes a predicate and returns a map whose key is a <code>Boolean</code>.
        There
        are two overloadings of this method, one of which takes a downstream collector in addition to a
        predicate.
    </p>

    <p>The collectors returned by the <code>counting</code> method are intended only for use as downstream
        collectors. The same functionality is available directly on <code>Stream</code>, via the
        <code>count</code>
        method, so there is never a reason to say <code>collect(counting())</code>. There are fifteen more
        <code>Collectors</code> methods with this property. They include the nine methods whose names begin with
        <code>summing</code>, <code>averaging</code>, and <code>summarizing</code> (whose functionality is
        available
        on the corresponding primitive stream types). They also include all overloadings of the
        <code>reducing</code> method, and the <code>filtering</code>, <code>mapping</code>,
        <code>flatMapping</code>, and <code>collectingAndThen</code> methods. Most programmers can safely ignore
        the
        majority of these methods. From a design perspective, these collectors represent an attempt to partially
        duplicate the functionality of streams in collectors so that downstream collectors can act as “mini
        streams.”
    </p>

    <p>There are three <code>Collectors</code> methods we have yet to mention. Though they are in
        <code>Collectors</code>, they don’t involve collections. The first two are <code>minBy</code> and
        <code>maxBy</code>, which take a comparator and return the minimum or maximum element in the stream as
        determined by the comparator. They are the collector analogues of the binary operators returned by the
        like-named methods in <code>BinaryOperator</code>. Recall that we used <code>BinaryOperator.maxBy</code>
        in
        our best-selling album example.
    </p>

    <p>The final <code>Collectors</code> method is <code>joining</code>, which operates only on streams of
        <code>CharSequence</code> instances such as strings. In its parameterless form, it returns a collector
        that
        simply concatenates the elements. Its one-argument form takes a single <code>CharSequence</code>
        parameter
        named <code>delimiter</code> and returns a collector that joins the stream elements, inserting the
        delimiter
        between adjacent elements. If you pass in a comma as the delimiter, the collector returns a
        comma-separated
        values string (but beware that the string will be ambiguous if any of the elements in the stream contain
        commas). The three-argument form takes a prefix and suffix in addition to the delimiter. The resulting
        collector generates strings like the ones that you get when you print a collection, for example
        <code>[came, saw, conquered]</code>.
    </p>

    <p>In summary, the essence of programming stream pipelines is side-effect-free function objects. This
        applies to
        all of the many function objects passed to streams and related objects. The terminal operation
        <code>forEach</code> should only be used to report the result of a computation performed by a stream,
        not to
        perform the computation. In order to use streams properly, you have to know about collectors. The most
        important collector factories are <code>toList</code>, <code>toSet</code>, <code>toMap</code>,
        <code>groupingBy</code>, and <code>joining</code>.
    </p>
</div>